package skrevent

import (
	"context"
	"sync"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestSkrRuntimeEventService_CancelMutexProtection(t *testing.T) {
	t.Run("concurrent Start and Stop operations are thread-safe", func(t *testing.T) {
		service := NewSkrRuntimeEventService(nil)

		var wgr sync.WaitGroup
		numGoroutines := 10
		errors := make([]error, numGoroutines*2) // For both Start and Stop operations

		// Launch concurrent Start and Stop operations
		for gri := range numGoroutines {
			wgr.Add(2) // One for Start, one for Stop

			go func(idx int) {
				defer wgr.Done()
				ctx, cancel := context.WithTimeout(t.Context(), 5*time.Millisecond)
				defer cancel()
				errors[idx*2] = service.Start(ctx)
			}(gri)

			go func(idx int) {
				defer wgr.Done()
				errors[idx*2+1] = service.Stop()
			}(gri)
		}

		wgr.Wait()

		// Stop operations should never return errors
		for i := 1; i < len(errors); i += 2 {
			assert.NoError(t, errors[i], "Stop operation should never return error")
		}
	})

	t.Run("multiple concurrent Stop calls are safe", func(t *testing.T) {
		service := NewSkrRuntimeEventService(nil)

		var wgr sync.WaitGroup
		numStops := 20
		errors := make([]error, numStops)

		// Multiple concurrent Stop calls
		for i := range numStops {
			wgr.Add(1)
			go func(idx int) {
				defer wgr.Done()
				errors[idx] = service.Stop()
			}(i)
		}

		wgr.Wait()

		// All Stop calls should succeed
		for i, err := range errors {
			assert.NoError(t, err, "Stop call %d should not return error", i)
		}
	})
}

func TestSkrRuntimeEventService_ForwardEventsGoroutineOrder(t *testing.T) {
	t.Run("Start method returns immediately with nil listener", func(t *testing.T) {
		service := NewSkrRuntimeEventService(nil)

		// The key test: Start should return immediately when listener is nil
		// (forwardEvents runs in a goroutine and waits for context)
		ctx, cancel := context.WithTimeout(t.Context(), 20*time.Millisecond)
		defer cancel()

		startTime := time.Now()
		err := service.Start(ctx)
		elapsed := time.Since(startTime)

		// With nil listener, Start() should return immediately (< 1ms typically)
		assert.Less(t, elapsed, 10*time.Millisecond, "Start should return immediately with nil listener, took %v", elapsed)
		assert.NoError(t, err, "Should not return error with nil listener")
	})

	t.Run("multiple Start calls handle goroutine creation properly", func(t *testing.T) {
		service := NewSkrRuntimeEventService(nil)

		// Test multiple quick Start calls to ensure goroutines are managed properly
		for range 3 {
			ctx, cancel := context.WithTimeout(t.Context(), 5*time.Millisecond)

			err := service.Start(ctx)

			// Should complete without error
			require.NoError(t, err, "Start should not return error")

			cancel()
		}
	})
}

func TestSkrRuntimeEventService_ChannelCloseProtection(t *testing.T) {
	t.Run("channel is closed only once with sync.Once", func(t *testing.T) {
		service := NewSkrRuntimeEventService(nil)

		// Start multiple forwardEvents goroutines to test sync.Once
		var wgr sync.WaitGroup
		numGoroutines := 5

		for range numGoroutines {
			wgr.Add(1)
			go func() {
				defer wgr.Done()
				ctx, cancel := context.WithTimeout(t.Context(), 5*time.Millisecond)
				defer cancel()
				service.forwardEvents(ctx)
			}()
		}

		wgr.Wait()

		// Verify channel is closed
		select {
		case _, ok := <-service.eventChannel:
			assert.False(t, ok, "Channel should be closed")
		default:
			// Channel might be closed but no value to read, which is also fine
		}
	})
}

func TestSkrRuntimeEventService_ContextHandling(t *testing.T) {
	t.Run("context cancellation is properly propagated", func(t *testing.T) {
		service := NewSkrRuntimeEventService(nil)

		// Use a very short timeout to test cancellation
		ctx, cancel := context.WithTimeout(t.Context(), 1*time.Millisecond)
		defer cancel()

		startTime := time.Now()
		err := service.Start(ctx)
		elapsed := time.Since(startTime)

		// Should complete quickly after context cancellation
		assert.Less(t, elapsed, 50*time.Millisecond, "Should respect context cancellation quickly")

		// Should return context-related error
		if err != nil {
			assert.ErrorIs(t, err, context.DeadlineExceeded)
		}
	})

	t.Run("child context is properly created and managed", func(t *testing.T) {
		service := NewSkrRuntimeEventService(nil)

		// Cancel the parent context after a short delay
		ctx, cancel := context.WithCancel(t.Context())

		go func() {
			time.Sleep(10 * time.Millisecond)
			cancel()
		}()

		startTime := time.Now()
		err := service.Start(ctx)
		elapsed := time.Since(startTime)

		// Should complete reasonably quickly after parent cancellation
		assert.Less(t, elapsed, 100*time.Millisecond, "Should complete quickly after parent context cancellation")

		if err != nil {
			assert.ErrorIs(t, err, context.Canceled)
		}
	})
}

func TestSkrRuntimeEventService_NilListenerHandling(t *testing.T) {
	t.Run("forwardEvents handles nil listener gracefully", func(t *testing.T) {
		service := NewSkrRuntimeEventService(nil)

		ctx, cancel := context.WithTimeout(t.Context(), 10*time.Millisecond)
		defer cancel()

		// This should not panic and should complete after context cancellation
		startTime := time.Now()
		service.forwardEvents(ctx)
		elapsed := time.Since(startTime)

		// Should complete around the timeout duration
		assert.GreaterOrEqual(t, elapsed, 8*time.Millisecond, "Should wait for context cancellation")
		assert.Less(t, elapsed, 50*time.Millisecond, "Should not take too long")
	})

	t.Run("Start with nil listener returns immediately", func(t *testing.T) {
		service := NewSkrRuntimeEventService(nil)

		ctx, cancel := context.WithTimeout(t.Context(), 15*time.Millisecond)
		defer cancel()

		startTime := time.Now()
		err := service.Start(ctx)
		elapsed := time.Since(startTime)

		// With nil listener, Start should return immediately (forwardEvents runs in goroutine)
		assert.Less(t, elapsed, 10*time.Millisecond, "Start should return immediately with nil listener, took %v", elapsed)
		assert.NoError(t, err, "Should not return error with nil listener")
	})
}

func TestSkrRuntimeEventService_Initialization(t *testing.T) {
	t.Run("service is properly initialized with correct fields", func(t *testing.T) {
		service := NewSkrRuntimeEventService(nil)

		// Verify service structure
		assert.NotNil(t, service, "Service should be created")
		assert.NotNil(t, service.eventChannel, "Event channel should be initialized")
		assert.Equal(t, 100, cap(service.eventChannel), "Event channel should have buffer size 100")

		// Initial state checks
		assert.Nil(t, service.listener, "Listener should be nil as provided")
		assert.Nil(t, service.cancel, "Cancel function should be nil initially")
	})

	t.Run("CreateEventSource returns valid source", func(t *testing.T) {
		service := NewSkrRuntimeEventService(nil)

		source := service.CreateEventSource(nil)
		assert.NotNil(t, source, "Event source should be created")

		// Multiple calls should work
		source2 := service.CreateEventSource(nil)
		assert.NotNil(t, source2, "Second event source should also be created")
	})
}
